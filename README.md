# üîê Auth67 - JWT Authentication Service

![Spring Boot](https://img.shields.io/badge/Spring%20Boot-3.5.9-green) ![Java](https://img.shields.io/badge/Java-21-orange) ![Security](https://img.shields.io/badge/JWT-Secure-blue) ![License](https://img.shields.io/badge/License-MIT-lightgrey)

**Auth67** is a robust authentication and authorization microservice built with Spring Boot 3. It implements a modern security architecture based on **JWT (JSON Web Tokens)** featuring role-based access control, token refreshing, and account locking mechanisms.

---

## üöÄ Main Features

*   **Stateless Authentication:** Session management using JWT (Access Token + Refresh Token).
*   **Role-Based Access Control (RBAC):**
    *   `ROLE_ADMIN`: User management and registration.
    *   `ROLE_USER`: Default role for standard users.
*   **Hardened Security:**
    *   Passwords encrypted with BCrypt.
    *   Global Exception Handling with unified error responses.
    *   Protection against locked/banned accounts.
*   **Lightweight Database:** Integrated SQLite for quick and easy deployment (easily migratable to PostgreSQL/MySQL).
*   **Validation:** Strict input data control using Jakarta Validation on DTOs.

---

## üìÇ Project Architecture

This project follows a **Screaming Architecture** approach, organizing code by **Features** rather than technical layers. This makes the codebase easier to navigate and scale.

```text
src/main/java/es/janrax/auth67/
‚îú‚îÄ‚îÄ auth                  <-- Feature: Core Authentication
‚îÇ   ‚îú‚îÄ‚îÄ api               (AuthController)
‚îÇ   ‚îú‚îÄ‚îÄ service           (AuthService)
‚îÇ   ‚îú‚îÄ‚îÄ security          (JwtService, Config, Filters)
‚îÇ   ‚îî‚îÄ‚îÄ dto               (LoginRequest, RegisterRequest...)
‚îú‚îÄ‚îÄ admin                 <-- Feature: User Management
‚îÇ   ‚îú‚îÄ‚îÄ api               (UserController)
‚îÇ   ‚îú‚îÄ‚îÄ service           (UserService)
‚îÇ   ‚îî‚îÄ‚îÄ dto               (UserResponse, UserUpdateRequest)
‚îî‚îÄ‚îÄ shared                <-- Shared Kernel
    ‚îú‚îÄ‚îÄ config            (Global Config)
    ‚îú‚îÄ‚îÄ domain            (Entities: User, Role)
    ‚îú‚îÄ‚îÄ repository        (Repositories: UserRepository...)
    ‚îî‚îÄ‚îÄ exception         (Global Error Handling)
```

---

## üõ†Ô∏è Technology Stack

*   **Core:** Java 21, Spring Boot 3.5.9
*   **Security:** Spring Security, JJWT (Java JWT)
*   **Persistence:** Spring Data JPA, Hibernate, SQLite
*   **Testing:** JUnit 5, MockMvc
*   **Tools:** Gradle, Lombok

---

## ‚öôÔ∏è Configuration

The project is auto-configured with sensible defaults, but you can customize them in `src/main/resources/application.properties`.

### Key Properties
| Property | Description | Default Value |
| :--- | :--- | :--- |
| `application.security.jwt.expiration` | Access Token lifetime (ms) | `300000` (5 min) |
| `application.security.jwt.refresh-token.expiration` | Refresh Token lifetime (ms) | `86400000` (24 h) |
| `application.security.admin.username` | Initial Admin Username | `admin` |
| `application.security.admin.password` | Initial Admin Password | `admin123` |

---

## üèÉ‚Äç‚ôÇÔ∏è How to Run

### Prerequisites
*   Java 21 installed.

### Commands
1.  **Clone the repository:**
    ```bash
    git clone https://github.com/your-user/auth67.git
    cd auth67
    ```

2.  **Run the application:**
    ```bash
    ./gradlew bootRun
    ```
    *An ADMIN user is automatically created on startup if it doesn't exist.*

3.  **Run tests:**
    ```bash
    ./gradlew test
    ```

---

## üîå API Endpoints

### üîì Public Endpoints
*   `POST /api/auth/login`: Authenticate and get tokens.
    *   **Body:** `{"username": "...", "password": "..."}`
    *   **Response:** `access_token`, `refresh_token`.

### üîí Secured Endpoints (Require `Authorization: Bearer <token>` header)

*   `POST /api/auth/refresh-token`: Get a new access token.
    *   **Body:** `{"refresh_token": "..."}`
*   `POST /api/auth/logout`: Log out (Client should remove tokens locally).

### üëÆ Admin Only (`ROLE_ADMIN`)

*   `POST /api/auth/register`: Register new users.
    *   **Body:** `{"username": "...", "password": "...", "roles": ["ROLE_USER"]}`

## Client Microservice Implementation Example

This section describes how to configure a **second microservice** (e.g., `special-service`) to trust the tokens generated by `auth67`.

### 0. Directory Structure
Your client microservice should follow this structure for the classes described below:

```text
src/main/java/com/example/client/
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ SecurityConfig.java
‚îú‚îÄ‚îÄ controller/
‚îÇ   ‚îî‚îÄ‚îÄ SpecialController.java
‚îî‚îÄ‚îÄ security/
    ‚îî‚îÄ‚îÄ JwtTokenFilter.java
```

### 1. Dependencies
Add these to the `build.gradle` of the new microservice:
```groovy
implementation 'org.springframework.boot:spring-boot-starter-security'
implementation 'org.springframework.boot:spring-boot-starter-web'
implementation 'io.jsonwebtoken:jjwt-api:0.12.6'
runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.6'
runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.6'
```

### 2. Configuration (`application.properties`)
Use the **same secret key** as the Auth Service:
```properties
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
```

### 3. JWT Filter (`JwtTokenFilter.java`)
This filter validates the token and extracts the roles without accessing the database.

```java
@Component
@RequiredArgsConstructor
public class JwtTokenFilter extends OncePerRequestFilter {

    @Value("${application.security.jwt.secret-key}")
    private String secretKey;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        
        String header = request.getHeader("Authorization");
        if (header == null || !header.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        String token = header.substring(7);
        try {
            SecretKey key = Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey));
            Claims claims = Jwts.parser().verifyWith(key).build().parseSignedClaims(token).getPayload();

            String username = claims.getSubject();
            List<String> roles = claims.get("roles", List.class); // Extract roles from token
            List<SimpleGrantedAuthority> authorities = roles.stream()
                    .map(SimpleGrantedAuthority::new)
                    .toList();

            UsernamePasswordAuthenticationToken auth = 
                new UsernamePasswordAuthenticationToken(username, null, authorities);
            
            SecurityContextHolder.getContext().setAuthentication(auth);
            filterChain.doFilter(request, response);
        } catch (Exception e) {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        }
    }
}
```

### 4. Security Configuration (`SecurityConfig.java`)
Enable method security to use `@PreAuthorize`.

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity // Essential for @PreAuthorize to work
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtTokenFilter jwtTokenFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(s -> s.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .addFilterBefore(jwtTokenFilter, UsernamePasswordAuthenticationFilter.class)
            .authorizeHttpRequests(auth -> auth.anyRequest().authenticated());

        return http.build();
    }
}
```

### 5. Protected Controller Example (`SpecialController.java`)
Here is the example of a controller in the **second microservice** that requires the specific `ROLE_SPECIAL_USER`.

```java
@RestController
@RequestMapping("/api/special")
public class SpecialController {

    @GetMapping
    @PreAuthorize("hasRole('SPECIAL_USER')")
    public String exclusiveEndpoint() {
        return "Access Granted: You have the ROLE_SPECIAL_USER in your JWT token.";
    }
}
```

---

## üõ°Ô∏è Error Handling

The API returns structured error responses for all exceptions:

```json
{
  "timestamp": "2025-12-24T12:00:00",
  "status": 403,
  "error": "Access Denied",
  "message": "You do not have permission to access this resource",
  "path": "/api/auth/register"
}
```

---

Made with ‚ù§Ô∏è by **janrax**.